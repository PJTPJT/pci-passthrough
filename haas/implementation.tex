\section{Implementation Details}
% Low-level implementation details include the hypervisor
% modifications.
% - Disable the HLT existing: KVM
% - DTID: KVM and timer-interrupt handler
% - Seamless VM migration: QEMU

\mycomment{
%MOSTLY REDUNDANT
In addition to the existing supports from the VT-x and VT-d,
Linux and its modules, QEMU and KVM, we modify the kernel, KVM
and QEMU and reach our goal of baremetal virtual machine. The
following features are provided. First, the guest has its own
dedicated CPU resources and PCIe devices. The guest's cores
are isolated, so no other host processes or threads compete
the CPU resources with the guest. Each virtual processor is
pinned to the isolated core in a one-to-one fashion. It is
important to move the host out of the way, when the guest is
idle. The VM exit due to the HTL instruction is disabled.
Second, the interrupts from the assigned devices and LAPIC
timer are handled directly by the guest without the hypervisor
intervention. Our approach utilizes the posted-interrupt
mechanism to deliver the local timer interrupt. It has the
requirement that the guest needs to set the PIR
timer-interrupt bit before the arrival of posted-interrupt
notification. While the host protects the posted-interrupt
descriptor, it shares the only the PID from the associated
VMCS. When the DTID is enabled in the host and guest, it
introduces spurious timer interrupts. The guest ignores the
fake timer interrupt, when the timer interrupt arrives earlier
than the expected. Third, the guest updates the LAPIC TMICT
directly. This is achieved by updating the MSR bitmap of
running guest. As a result, when the guest writes its next
period to the LAPIC TMICT, it does not trigger a VM exit and
avoids the overhead of interrupt processing and complexity of
\texttt{hrtimer} subsystem in the host. Fourth, when switching
the traffic from the passthrough to the virtual network
device, the network service down time is reduced by the
Ethernet bonding driver. Furthermore, the network service down
time is eliminated when hot plugging the assigned network
device to the running guest.



\subsection{Disable HLT Exiting and Update the MSR Bitmap}
To disable HLT-related VM exit, the HLT-exiting bit of
processor-based VM-execution control of VMCS is cleared. Our
implementation uses the existing KVM function to set or unset
the HLT-exiting bit. The function is \texttt{vmcs\_write64}.
To update the MSR bitmap, we disable the VM exit due to TMICT
WRMSR. The function is
\texttt{vmx\_disable\_intercept\_msr\_x2apic}. We uses this
function as the prototype and enable the TMICT WRMSR VM exits,
while consulting the MSR bitmap from the Intel Software
Developer Manual.
}

\subsection{CPU Idleness Processing}

When a CPU on a Linux-based physical machine does not have any applications to run and becomes idle,
Linux schedules a special idle task to run on the CPU. On X86 CPU, this idle task consists of a loop of {\tt HLT} instructions, 
each of which places the CPU in the C1 energy-saving mode until an external interrupt occurs.
Because {\tt HLT} is a privileged instruction, its execution inside a guest VM triggers a VM exit and causes the control to be transferred to KVM. 
Currently, KVM emulates a {\tt HLT} instruction using a busy waiting loop, which polls the CPU until the associated external interrupt comes along. 
%One of our design goals is to let the guest stay on its CPU as
%long as it can. We encounter two different types of
%virtualization overheads. First, the idle guest issues the
%privileged HLT instruction. Such an instruction induces the VM
%exit and transfers the control to the KVM which starts to poll
%on the CPU until the event arrival. 

This polling-loop emulation of {\tt HLT} instruction incurs higher CPU utilization than that when {\tt HLT} instruction is executed natively. 
To address this issue, \na prevents VM exit when executing a {\tt HLT} instruction inside a VM by modifying the VM-execution control fields 
in the VM's virtual machine control structure (VMCS).
As a result, whenever a CPU becomes idle, no {\tt HLT}-related VM exits occur, the CPU lowers its clock frequency, and the total energy consumption is reduced. 
%It is eliminated
%by updating the primary processor-based VM execution control
%and disabling the VM exit due to the HLT instruction. It
%allows the idle guest to stay on its CPU without polling
%and results in the CPU clock frequency remains at minimal.
%Thus, disabling HLT-induced VM exit helps to reduce the CPU
%power consumption of idle guest. 
%Second, the local timer
%interrupt fires and causes the VM exit, when the guest's time
%quantum is expired. The longer the guest stays on its CPU, the
%higher number of physical timer interrupt it receives. 

%To support our objective, our work utilizes the posted-interrupt
%mechanism and directly deliver the interrupt into the guest
%without triggering any VM exit. This feature is discussed in
%Interrupts that wake a CPU up from the {\tt HLT}-induced energy-saving mode used to go through the hypervisor and thus may incur additional VM exits.
%As disucussed in the~\nameref{subsubsec:shared_pid_dtid}, we leverage X86's {\em posted interrupt} mechanism to deliver these interrupts directly to a VM in the energy-saving mode.
%Consequently, processing of CPU idleness incurs no VM exit, as is the case when the user OS runs directly on a bare metal server.

\subsection{PID Sharing}

In \sna, a CPU core's PID is accessible is accessible to the IOMMU (Interrupt Remapping Table), the hypervisor and the HaaS running on the CPU core. 
Originally, the PID  is embedded within the
\texttt{vcpu\_vmx} structure. To make a PID only accessible to the associated HaaS VM,
when a vCPU is created, \na allocates a separate page for its PID, and places the PID's base address in the vCPU's VMCS, and in all the Interrupt Remapping Table entries for those interrupts that are destined to the vCPU.
To enable the vCPU's associated VM to access this PID page, the VM's OS provides the address of a page in the guest physical address space to the hypervisor via a hypercall, and the hypervisor maps this address to the host physical address of the PID page in QEMU's page table and the Extended Page Table (EPT)~\cite{ept-wiki}, and updates the PID page's reference count accordingly.
   
\mycomment{
and extended page table entry to the physical location of
shared page and the reference count of shared page. To have
the DTID reversible, the implementation saves the host
physical address of target GPA. When the DTID is torn down,
our implementation reverts the PTE and EPTE back to the saved
HPA and updates the reference counts of shared page. Second,
the TMICT WRMSR VM exit is disabled, so the guest is able to
update its TMICT without the additional cost. Third, the host
needs to inform the gust the multiplication and shift factor
of calibrated LAPIC timer. When the guest programs the LAPIC
TMICT, it needs the right factor to convert the duration in
time to the number of clock cycles. Fourth, we implement the
screening algorithm in the guest timer interrupt handlers,
\texttt{smp\_apic\_timer\_interrupt} and
\texttt{local\_apic\_timer\_interrupt}. If the timer interrupt
arrives than the expected expiration, it is the spurious
interrupt. Then, the guest ignores it by skipping the regular
processing of timer interrupt. Fifth, the guest updates the
PIR timer-interrupt bit, whenever it receives the timer
interrupt. 
}

According to Intel IA-32 Intel Architecture Software Developer's
Manual~\cite{sdm:2018}, all accesses to the PID
must use the locked read-modify-write instruction to ensure mutual exclusion. 
In \sna, when network packets come in at a high rate, a HaaS VM may repeatedly turn on the timer interrupt bit in the PIR to process spurious timer interrupts that come with NIC interrupts. However, these accesses to the PIR, being based on the atomic test-and-set instruction, may prevent the Interrupt Remapping Table from accessing the PIR on behalf of incoming packets, and cause some of these packets to be dropped and eventually degraded network performance.
 
\na solves this performance problem by requiring a HaaS VM to set the timer interrupt bit
in the PIR using a non-atomic instruction, which immediately cuts down the lock contention
and boosts the network performance. This lockless design is safe because the PIR bits that a HaaS VM and the Interrupt Remapping Table are guaranteed to be disjoint and thus do not need to be locked before being accessed.


\subsection{NIC Bonding}
Linux's bonding driver provides a \texttt{fail\_over\_mac} option to change 
the MAC address of the bonded interface and broadcast ARP packets for the new MAC address when the Active slave fails. \na configures the bonding driver by setting   
\texttt{fail\_over\_mac} to 1, and cuts down the
network downtime due to hot unplug operations.


\na uses the QEMU command \texttt{device\_add} to implement a hot plug operation,
and the QEMU command \texttt{device\_del} to implement a hot unplug operation. 
and the control is transferred back (hot unplug) to host 
The \texttt{device\_del} command itself is further broken down 
into three commands \texttt{setup\_nic}, which sets up a software NIC object, 
\texttt{realize\_vfio\_nic}, which configures a software NIC object, and \texttt{reset\_nic\_device}, which resets a software NIC object by setting the 
BARs and redirecting the associated interrrupts. 
The \texttt{setup\_nic} and \texttt{reset\_nic\_device} command must be executed when the VM issuing them is paused. 
