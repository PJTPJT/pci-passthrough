\subsection{Implementation-specific Details}
% Low-level implementation details include the hypervisor
% modifications.
% - Disable the HLT existing: KVM
% - DTID: KVM and timer-interrupt handler
% - Seamless VM migration: QEMU

{\bf Code Changes:}
The hypervisor in \na takes up 80-120 MB of memory of the physical machine it runs on when it is idle.
DTID requires modifications to the guest OS, and entails 387 lines of code changes: 43 lines are added to the timer subsystem, 110 lines adjusts the clock multiplication and shift factor, and 234 lines map/unmap/test the shared PID page and cleanup.

\mycomment{
%MOSTLY REDUNDANT
In addition to the existing supports from the VT-x and VT-d,
Linux and its modules, QEMU and KVM, we modify the kernel, KVM
and QEMU and reach our goal of baremetal virtual machine. The
following features are provided. First, the guest has its own
dedicated CPU resources and PCIe devices. The guest's cores
are isolated, so no other host processes or threads compete
the CPU resources with the guest. Each virtual processor is
pinned to the isolated core in a one-to-one fashion. It is
important to move the host out of the way, when the guest is
idle. The VM exit due to the HTL instruction is disabled.
Second, the interrupts from the assigned devices and LAPIC
timer are handled directly by the guest without the hypervisor
intervention. Our approach utilizes the posted-interrupt
mechanism to deliver the local timer interrupt. It has the
requirement that the guest needs to set the PIR
timer-interrupt bit before the arrival of posted-interrupt
notification. While the host protects the posted-interrupt
descriptor, it shares the only the PID from the associated
VMCS. When the DTID is enabled in the host and guest, it
introduces spurious timer interrupts. The guest ignores the
fake timer interrupt, when the timer interrupt arrives earlier
than the expected. Third, the guest updates the LAPIC TMICT
directly. This is achieved by updating the MSR bitmap of
running guest. As a result, when the guest writes its next
period to the LAPIC TMICT, it does not trigger a VM exit and
avoids the overhead of interrupt processing and complexity of
\texttt{hrtimer} subsystem in the host. Fourth, when switching
the traffic from the passthrough to the virtual network
device, the network service down time is reduced by the
Ethernet bonding driver. Furthermore, the network service down
time is eliminated when hot plugging the assigned network
device to the running guest.



\subsection{Disable HLT Exiting and Update the MSR Bitmap}
To disable HLT-related VM exit, the HLT-exiting bit of
processor-based VM-execution control of VMCS is cleared. 
Our
implementation uses the existing KVM function to set or unset
the HLT-exiting bit. The function is \texttt{vmcs\_write64}.
To update the MSR bitmap, we disable the VM exit due to TMICT
WRMSR. The function is
\texttt{vmx\_disable\_intercept\_msr\_x2apic}. We uses this
function as the prototype and enable the TMICT WRMSR VM exits,
while consulting the MSR bitmap from the Intel Software
Developer Manual.

\subsection{CPU Idleness Processing}

When a CPU on a Linux-based machine does not have any applications to run,
Linux schedules a special idle task to run on the CPU. On X86 CPU, this idle task consists of a loop of {\tt HLT} instructions, 
each of which places the CPU in the C1 energy-saving mode until an external interrupt occurs.
Because {\tt HLT} is a privileged instruction, its execution inside a guest VM triggers a VM exit and causes the control to be transferred to KVM. 
Currently, KVM emulates a {\tt HLT} instruction using a busy waiting loop, which polls the CPU until the associated external interrupt comes along. 
%One of our design goals is to let the guest stay on its CPU as
%long as it can. We encounter two different types of
%virtualization overheads. First, the idle guest issues the
%privileged HLT instruction. Such an instruction induces the VM
%exit and transfers the control to the KVM which starts to poll
%on the CPU until the event arrival. 

This polling-loop emulation of {\tt HLT} instruction incurs higher CPU utilization than that when {\tt HLT} instruction is executed natively. 
To address this issue, \na prevents VM exit when executing a {\tt HLT} instruction inside a HaaS VM by modifying the VM-execution control fields 
in the VM's virtual machine control structure (VMCS).
As a result, whenever a CPU becomes idle, no {\tt HLT}-related VM exits occur, the CPU lowers its clock frequency, and the total energy consumption is reduced. 
%It is eliminated
%by updating the primary processor-based VM execution control
%and disabling the VM exit due to the HLT instruction. It
%allows the idle guest to stay on its CPU without polling
%and results in the CPU clock frequency remains at minimal.
%Thus, disabling HLT-induced VM exit helps to reduce the CPU
%power consumption of idle guest. 
%Second, the local timer
%interrupt fires and causes the VM exit, when the guest's time
%quantum is expired. The longer the guest stays on its CPU, the
%higher number of physical timer interrupt it receives. 

%To support our objective, our work utilizes the posted-interrupt
%mechanism and directly deliver the interrupt into the guest
%without triggering any VM exit. This feature is discussed in
%Interrupts that wake a CPU up from the {\tt HLT}-induced energy-saving mode used to go through the hypervisor and thus may incur additional VM exits.
%As disucussed in the~\nameref{subsubsec:shared_pid_dtid}, we leverage X86's {\em posted interrupt} mechanism to deliver these interrupts directly to a VM in the energy-saving mode.
%Consequently, processing of CPU idleness incurs no VM exit, as is the case when the user OS runs directly on a bare-metal server.
}

{\bf Guest OS access to the PIR bitmap:}
The Posted-Interrupt Descriptor (PID) contains the PIR bitmap 
which the guest OS must access for direct timer interrupt delivery in \sna.
A CPU core's PID is accessible to the IOMMU (Interrupt Remapping Table), 
the hypervisor, and (in \sna) to  the HaaS VM running on the CPU core. 
%Originally, the PID  is embedded within the HaaS VM's VMCS structure.
To make a PID accessible to the HaaS VM's guest OS,
when a VCPU is created, \na allocates a separate page for its PID, 
and places the PID's base address in the VCPU's VMCS, and 
in all the Interrupt Remapping Table entries that target at the VCPU.
%To enable the VCPU's associated VM to access this PID page, 
The guest OS provides the address of a page in the guest physical address 
space to the hypervisor via a hypercall, and the hypervisor maps this address 
to the host physical address of the PID page in QEMU's page table and 
the Extended Page Table (EPT)~\cite{ept-wiki}, and updates the 
PID page's reference count accordingly.
   
\mycomment{
and extended page table entry to the physical location of
shared page and the reference count of shared page. To have
the DTID reversible, the implementation saves the host
physical address of target GPA. When the DTID is torn down,
our implementation reverts the PTE and EPTE back to the saved
HPA and updates the reference counts of shared page. Second,
the TMICT WRMSR VM exit is disabled, so the guest is able to
update its TMICT without the additional cost. Third, the host
needs to inform the gust the multiplication and shift factor
of calibrated LAPIC timer. When the guest programs the LAPIC
TMICT, it needs the right factor to convert the duration in
time to the number of clock cycles. Fourth, we implement the
screening algorithm in the guest timer interrupt handlers,
\texttt{smp\_apic\_timer\_interrupt} and
\texttt{local\_apic\_timer\_interrupt}. If the timer interrupt
arrives than the expected expiration, it is the spurious
interrupt. Then, the guest ignores it by skipping the regular
processing of timer interrupt. Fifth, the guest updates the
PIR timer-interrupt bit, whenever it receives the timer
interrupt. 
}

%According to Intel IA-32 Intel Architecture Software Developer's Manual~\cite{sdm:2018} 
Intel IA-32 Intel Architecture~\cite{sdm:2018}  requires that all accesses to the PIR bitmap in a PID
must use the locked read-modify-write instruction to ensure mutual exclusion. 
In \sna, when network packets come in at a high rate, a HaaS VM may repeatedly turn 
on the timer interrupt bit in the PIR bitmap to ignore  spurious timer interrupts that 
accompany the NIC interrupts. However, these accesses to the PIR, being based on the
atomic test-and-set instruction, may prevent the Interrupt Remapping Table from 
accessing the PIR on behalf of incoming packets, and cause some of these 
packets to be dropped, eventually degrading the network performance.
 
\na solves this performance problem by requiring a HaaS VM to set the timer interrupt bit
in the PIR using a non-atomic instruction, which immediately cuts down the extent of lock contention
and boosts the network performance. This lockless design is safe because the PIR bits 
that the HaaS VM and the Interrupt Remapping Table access are guaranteed to be 
disjoint and thus do not need to be locked before being accessed.


{\bf NIC Bonding}
Linux's bonding driver provides a \texttt{fail\_over\_mac} option to change 
the MAC address of the bonded interface and broadcast ARP packets for the new MAC address 
when the Active slave fails. \na configures the bonding driver by setting   
\texttt{fail\_over\_mac} to 1, and cuts down the
network downtime due to hot unplug operations.

To transition a NIC between the VFIO and Vhost mode, \na hot-plugs and hot-unplugs the corresponding devcices at the right times.  It uses the QEMU command \texttt{device\_add} to implement a hot plug operation, and the QEMU command \texttt{device\_del} to implement a hot unplug operation. 



\mycomment{
\texttt{device\_add} transfers the control of NIC device from host to guest and.
on \texttt{device\_del} command the NIC device control is transferred back to host. 
In \na, the \texttt{device\_del} command itself is further broken down 
into three commands \texttt{setup\_nic}, which sets up a software NIC object, 
\texttt{realize\_vfio\_nic}, which configures a software NIC object, and \texttt{reset\_nic\_device}, which resets a software NIC object by setting the 
BARs and redirecting the associated interrrupts. 
The \texttt{setup\_nic} and \texttt{reset\_nic\_device} commands must be executed when the VM issuing them is paused. The \texttt{reset\_nic\_device} command is issued on VM resumption. 
}




