\section{Implementation}
% Low-level implementation details include the hypervisor
% modifications.
% - Disable the HLT existing: KVM
% - DTID: KVM and timer-interrupt handler
% - Seamless VM migration: QEMU

%\figw{cpu_state_diagram}{10}{CPU state diagram}

In addition to the existing supports from the VT-x and VT-d,
Linux and its modules, QEMU and KVM, we modify the kernel, KVM
and QEMU and reach our goal of baremetal virtual machine. The
following features are provided. First, the guest has its own
dedicated CPU resources and PCIe devices. The guest's cores
are isolated, so no other host processes or threads compete
the CPU resources with the guest. Each virtual processor is
pinned to the isolated core in a one-to-one fashion. It is
important to move the host out of the way, when the guest is
idle. The VM exit due to the HTL instruction is disabled.
Second, the interrupts from the assigned devices and LAPIC
timer are handled directly by the guest without the hypervisor
intervention. Our approach utilizes the posted-interrupt
mechanism to deliver the local timer interrupt. It has the
requirement that the guest needs to set the PIR
timer-interrupt bit before the arrival of posted-interrupt
notification. While the host protects the posted-interrupt
descriptor, it shares the only the PID from the associated
VMCS. When the DTID is enabled in the host and guest, it
introduces spurious timer interrupts. The guest ignores the
fake timer interrupt, when the timer interrupt arrives earlier
than the expected. Third, the guest updates the LAPIC TMICT
directly. This is achieved by updating the MSR bitmap of
running guest. As a result, when the guest writes its next
period to the LAPIC TMICT, it does not trigger a VM exit and
avoids the overhead of interrupt processing and complexity of
\texttt{hrtimer} subsystem in the host. Fourth, when switching
the traffic from the passthrough to the virtual network
device, the network service down time is reduced by the
Ethernet bonding driver. Furthermore, the network service down
time is eliminated when hot plugging the assigned network
device to the running guest.

\subsection{Disable HLT Exiting and Update the MSR Bitmap}
To disable HLT-related VM exit, the HLT-exiting bit of
processor-based VM-execution control of VMCS is cleared. Our
implementation uses the existing KVM function to set or unset
the HLT-exiting bit. The function is \texttt{vmcs\_write64}.
To update the MSR bitmap, we disable the VM exit due to TMICT
WRMSR. The function is
\texttt{vmx\_disable\_intercept\_msr\_x2apic}. We uses this
function as the prototype and enable the TMICT WRMSR VM exits,
while consulting the MSR bitmap from the Intel Software
Developer Manual.

\subsection{Direct Timer Interrupt Delivery}
The core of DTID implementation relies on the following
components. First, the PID is shared among the host, guest and
VT-d. Before our modification, the PID is embedded within the
\texttt{vcpu\_vmx} structure. If we simply shares the page
where the PID is located, we also allows the guest access to
the sensitive or privilege information in the host and thus,
put the host in a greater risk. Our implementation isolates
the PID into its own page and modifies the way how some KVM
functions access the PID. The PID is located in the beginning
of the page and accessed as a pointer. During the vCPU
creation, the PID page is allocated. When KVM sets up the VMCS
for each vCPU, the physical address of PID is stored in the
field of posted-interrupt descriptor address. As a result, the
PID is accessible from both KVM and VT-d. Before the guest
access the shared PID page, it needs to tell the host where to
map the shared page. The guest issues the hypercall and passes
the target guest physical address to the host. Once the host
receives the GPA, the host updates the QEMU page table entry
and extended page table entry to the physical location of
shared page and the reference count of shared page. To have
the DTID reversible, the implementation saves the host
physical address of target GPA. When the DTID is torn down,
our implementation reverts the PTE and EPTE back to the saved
HPA and updates the reference counts of shared page. Second,
the TMICT WRMSR VM exit is disabled, so the guest is able to
update its TMICT without the additional cost. Third, the host
needs to inform the gust the multiplication and shift factor
of calibrated LAPIC timer. When the guest programs the LAPIC
TMICT, it needs the right factor to convert the duration in
time to the number of clock cycles. Fourth, we implement the
screening algorithm in the guest timer interrupt handlers,
\texttt{smp\_apic\_timer\_interrupt} and
\texttt{local\_apic\_timer\_interrupt}. If the timer interrupt
arrives than the expected expiration, it is the spurious
interrupt. Then, the guest ignores it by skipping the regular
processing of timer interrupt. Fifth, the guest updates the
PIR timer-interrupt bit, whenever it receives the timer
interrupt. From the Intel Software Developer
Manual~\cite{sdm:2018}, it is the general requirement to use
the locked read-modify-write instruction to access the PID. If
the guest uses the atomic test-and-set instruction to set the
PIR bit, it prevents the KVM and VT-d from accessing the PID
during the time of operation. Such an atomic instruction
causes the processor's lock signal which ensures the exclusive
usage of shared PID and lock the cache line. Because of the
induced spurious interrupts from the guest I/O activities, the
guest locks the shared PID so often and prohibits the VT-d to
set the proper bit. Thus, the guest I/O performance is
degraded. Since the guest only updates the PIR timer-interrupt
bit, it is not necessary to lock it. In our implementation, we
choose to use the non-atomic operation to set the bit. This
effectively reduces the chance of lock contention.

\subsection{Migration of guest with passthrough NIC}
\input{temp/qemu_device_passthrough}
