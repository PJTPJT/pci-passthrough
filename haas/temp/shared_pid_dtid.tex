% Working on the shared-pid DTID.
% Direct timer-interrupt delivery
%   - periodic vs aperiodic timer interrupt
%   - one-shot vs periodic hardware timer interrupt
%   - guest-level access to the PIR page
%   - Eliminate the hardware lock, when the guest accesses
%     the PIR bit
%   - Spurious timer interrupts
The longer the guest stays on its CPU, the more local timer
interrupts it receives. The goal is to let the guest have its
dedicated CPUs. Our design does not only directly deliver the
timer interrupts to the guest, but also take one step further
by allowing the guest update its next timer event directly.

The local timer interrupt is delivered to the guest and
results in two scenarios. First, the timer interrupt is meant
for the guest. It induces the VM exit and the control is
transferred back to the host. The host handles the timer
interrupt and injects the virtual timer interrupt to the
guest. When the guest receives the virtual timer interrupt, it
services the timer interrupt and set up the next timer event
by updating the LAPIC timer initial count register through the
x2APIC interface. This triggers the MSR-write VM exit and the
control is transfer to the host. The host helps the guest to
set up its next timer by registering the \texttt{hrtimer}
object of guest next timer event. Second, the timer interrupt
is not meant for the guest. It induces the VM exit and
transfer the control back to the host. The host processes the
timer interrupt but does not inject the virtual timer
interrupt. Nonetheless, if the timer interrupt is not meant
for the guest, the guest should not pay the price.

The first task is to transform the local timer interrupt into
the posted interrupt, which is directly delivered to the guest
by the VT-d hardware. It requires two actions. The
timer-interrupt bit of posted-interrupt request needs to be
set, before the posted-interrupt notification is delivered to
the guest core. Since the guest is responsible for its own
timer interrupt, the guest should set the bit in the PIR.
However, such a PIR structure is embedded in the
posted-interrupt descriptor and protected by the host. The
host needs to share the PIR with the guest by isolating the
entire PID to a shared page. If the guest messes up setting
the proper bits in the PID, it does not affect the host normal
operations. In our design, the shared PID page is accessible
by three entities: host, guest and virtualization hardware.
The second task is to allow the guest control the timer
initial count register of LAPIC timer. With the
hardware-assisted APIC virtualization, this is achieved by
updating the MSR bitmap of VM control structure. The KVM
intercept of TMICT MSR update is disabled. When the guest
configures the TMICT, the change is written to the register
directly without triggering the VM exit. In summary, we reach
our goal of guest having dedicated CPUs by disabling the HLT-
and timer-related VM exits.

Using the shared PID has the draw back. It induces the
spurious timer interrupts causing additional interrupt
processing in the guest. Since the guest sets the PIR
timer-interrupt bit before its next timer event, the it
induces the spurious timer interrupts. Such a fake timer
interrupt is induced in two cases. First, the guest
experiences the spurious timer interrupt when performing
I/O-bound activities with the assigned device. Let's take the
assigned network card for an example. Both the bits of timer
interrupt and network-device interrupt are set in the PIR.
Based on the Intel architecture, the timer interrupt has a
higher priority than the network interrupt does. The timer
interrupt is delivered before the network interrupt. Although
the guest should have only processed the network interrupt, it
first processes the timer and then network interrupt. Second,
upon the VM entry, the PIR is synced to the virtual
interrupt-request register because of the KVM implementation.
One of time points to evaluate the virtual interrupt delivery
is at the VM entry time. If the PIR timer-interrupt bit is
present during the copy, the fake virtual timer interrupt is
delivered into the guest. To reduce the CPU overhead of
handling spurious interrupts, the guest ignores the spurious
interrupts.
